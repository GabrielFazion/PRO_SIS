# V_args é um decorador que permite que passemos alguns parametros para a classe Transformer
import argparse
from lark import Lark, Transformer, v_args

# Aqui instanciamos a classe do nosso interpretador, que herda da classe Transformer
# a classe Transformer, por sua vez, será responsável por 
class ProSisInterpreter(Transformer):
    """
    This class will passthrough the syntax tree generated by Lark and 
    execute actions based on it grammar rules.
    """

    def __init__(self):
        self.vars = {} # Inicializamos um dicionário para armazenar as variáveis declaradas

    # Métodos de transformação para as regras de gramática
    def programa(self, items):
        
        nome_programa = items[0].value
        print("Programa: ", nome_programa)
        print("-=-=-=- Executando o sistema de equações -=-=-=-")
        # items[1] eh declaracao e items[2] eh sistema
        return "Programa analisado com sucesso!"
    
    
    def declaracao_lista(self, items):
        """
        Declara variáveis a partir de uma lista de informações, exibindo detalhes das declarações.

        Para cada variável em 'items', composta por um tipo e um nome:
            - Exibe o nome e o tipo da variável declarada.
            - Verifica se o nome já foi declarado anteriormente em 'self.vars'.
            - Se já existir, lança uma exceção informando a duplicidade.
            - Caso contrário, adiciona a variável ao dicionário 'self.vars' com seu tipo e valor inicial None.

        Ao final, imprime um separador visual e retorna a lista de variáveis declaradas.

        Parâmetros:
            items (list): Lista de tuplas, onde cada tupla contém (tipo, nome) da variável.
        Retorna:
            list: A lista de variáveis declaradas (mesmo valor recebido em 'items').
        Exceções:
            Exception: Se uma variável com o mesmo nome já tiver sido declarada.
        """
        print(" ---- Variáveis Declaradas ---- ")
        for tipo, nome in items:
            print(f" Nome: {nome}, Tipo: {tipo}")
            if nome in self.vars:
                raise Exception(f"Erro: A variável com o nome '{nome}' já foi declarada!")
            self.vars[nome] = {'tipo': tipo, 'valor': None}
        print("----------------------------------------\n")
        return items
    
    def declaracao(self, items):
        tipo_token = items[0]
        id_token = items[1]
        return (tipo_token.value, id_token.value)
    
    def tipo(self, items):
        return items[0].value


    # Expressões aritméticas
    
    @v_args(inline=True) # as classes filhas recebem os argumentos de *args, ao invés de uma lista de argumentos
    def termo(self, *args): 
        # simplificado: apenas retorna a expressão como string
        return " ".join(map(str, args))
    
    @v_args(inline=True)
    def expr(self, *args):
        return " ".join(map(str, args))
    
    @v_args(inline=True)
    def _fator(self, item):
        # Se o 'fator' for um ID (uma variavel), verificamos se ele foi declarado
        if isinstance(item, v_args.Token) and item.type == 'ID':
            raise Exception(f"Erro Semântico: Variável '{item.value}' não declarada!")
        return item.value
    
    def NUMERO(self, token):
        return float(token.value)
    
# Pensei em abstrair um pouco mais os códigos, definindo uma main e um código à parte pra rodar
# Assim, as modificações podem ser feitas em arquivos distintos, sem interferir nas classes criadas
class ProSisCompiler:

    def __init__(self, grammar_file):
        """
        Inicializa o compilador carregando o arquivo de Lark de gramática uma única vez
        """

        try:
            with open(grammar_file) as f:
                self.pro_sis_parser = Lark(f.read(), start='programa')
            self.interpreter = ProSisInterpreter()
        except FileNotFoundError:
            raise Exception(f"Erro: Arquivo de gramática '{grammar_file}' não encontrado")
        
    
    def run(self, code_to_run):
        """
        Executa a análise e interpretação de um código fonte.
        """

        # 1. Parsing (Análise sintática)
        tree = self.pro_sis_parser.parse(code_to_run)
        print("------- Árvore Sintática Gerada --------")
        print(tree.pretty())
        print("----------------------------------------")
        
        #2. Análise semântica e Interpretação
        result = self.interpreter.transform(tree)
        return result
    
def main():
    # criamos um parser de argumentos para a linha de comando
    cli_parser = argparse.ArgumentParser(description="Interpretador para a linguagem PRO-SIS")
    cli_parser.add_argument("arquivo_entrada", help="Caminho para o arquivo .psis a ser executado.")

    args = cli_parser.parse_args()

    try:
        with open(args.arquivo_entrada, 'r') as f:
            codigo_fonte = f.read()
    except FileNotFoundError:
        print(f"Erro: Arquivo de entrada '{args.arquivo_entrada}' não encontrado.")
        return

    # executa o compilador
    try:
        print(f"Iniciando a compilação do arquivo '{args.arquivo_entrada}'...")
        compiler = ProSisCompiler("pro_sis_grammar.lark")
        result = compiler.run(codigo_fonte)
        print("\n", result)
    except Exception as e:
        print(f"Ocorreu um erro durante a compilação: {e}")

if __name__ == "__main__":
    main()